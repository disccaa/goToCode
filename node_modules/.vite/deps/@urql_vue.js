import {
  getCurrentInstance,
  inject,
  isRef,
  onBeforeUnmount,
  onMounted,
  provide,
  reactive,
  ref,
  watchEffect
} from "./chunk-QLWBXHOQ.js";

// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// node_modules/graphql/jsutils/inspect.mjs
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i2 = 0; i2 < len; ++i2) {
    items.push(formatValue(array[i2], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}

// node_modules/graphql/language/ast.mjs
var Location = class {
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
};
var Token = class {
  constructor(kind, start, end, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
};
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// node_modules/graphql/language/visitor.mjs
var BREAK = Object.freeze({});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}

// node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i2 = 0; i2 < lines.length; ++i2) {
    var _firstNonEmptyLine;
    const line = lines[i2];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i2;
    lastNonEmptyLine = i2;
    if (i2 !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i2) => i2 === 0 ? line : line.slice(commonIndent)).slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);
}
function leadingWhitespace(str) {
  let i2 = 0;
  while (i2 < str.length && isWhiteSpace(str.charCodeAt(i2))) {
    ++i2;
  }
  return i2;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, printDocASTReducer);
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join([
        node.operation,
        join([node.name, varDefs]),
        join(node.directives, " ")
      ], " ");
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value }) => name + ": " + value
  },
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join([
      "...",
      wrap("on ", typeCondition),
      join(directives, " "),
      selectionSet
    ], " ")
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
  },
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value }) => name + ": " + value
  },
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
  },
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type }) => "[" + type + "]"
  },
  NonNullType: {
    leave: ({ type }) => type + "!"
  },
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join([
      "type",
      name,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join([
      "interface",
      name,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(["union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join([
      "extend type",
      name,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join([
      "extend interface",
      name,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join([
      "extend union",
      name,
      join(directives, " "),
      wrap("= ", join(types, " | "))
    ], " ")
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}

// node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}

// node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}

// node_modules/graphql/language/location.mjs
var LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}

// node_modules/graphql/language/printLocation.mjs
function printLocation(location) {
  return printSourceLocation(location.source, getLocation(location.source, location.start));
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i2 = 0; i2 < locationLine.length; i2 += 80) {
      subLines.push(locationLine.slice(i2, i2 + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}

// node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
var GraphQLError = class extends Error {
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== void 0 ? path : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0);
    const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null));
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(originalError === null || originalError === void 0 ? void 0 : originalError.extensions) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
};
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}

// node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}

// node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// node_modules/graphql/language/lexer.mjs
var Lexer = class {
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  advance() {
    this.lastToken = this.token;
    const token = this.token = this.lookahead();
    return token;
  }
  lookahead() {
    let token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        if (token.next) {
          token = token.next;
        } else {
          const nextToken = readNextToken(this, token.end);
          token.next = nextToken;
          nextToken.prev = token;
          token = nextToken;
        }
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  }
};
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
}
function isSupplementaryCodePoint(body, location) {
  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
}
function isLeadingSurrogate(code) {
  return code >= 55296 && code <= 56319;
}
function isTrailingSurrogate(code) {
  return code >= 56320 && code <= 57343;
}
function printCodePointAt(lexer, location) {
  const code = lexer.source.body.codePointAt(location);
  if (code === void 0) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? `'"'` : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
}
function readNextToken(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(lexer.source, position, code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(lexer, TokenKind.COMMENT, start, position, body.slice(start + 1, position));
}
function readNumber(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);
  }
  return createToken(lexer, isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, body.slice(start, position));
}
function readDigits(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(lexer.source, start, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start)}.`);
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
}
function readString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape.value;
      position += escape.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + size)}".`);
}
function readEscapedUnicodeFixedWidth(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`);
}
function read16BitHexCode(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
}
function readHexDigit(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
}
function readEscapedCharacter(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(lexer.source, position, `Invalid character escape sequence: "${body.slice(position, position + 2)}".`);
}
function readBlockString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(lexer, TokenKind.BLOCK_STRING, start, position + 3, dedentBlockStringLines(blockLines).join("\n"));
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readName(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(lexer, TokenKind.NAME, start, position, body.slice(start, position));
}

// node_modules/graphql/jsutils/instanceOf.mjs
var instanceOf = false ? function instanceOf2(value, constructor) {
  return value instanceof constructor;
} : function instanceOf3(value, constructor) {
  if (value instanceof constructor) {
    return true;
  }
  if (typeof value === "object" && value !== null) {
    var _value$constructor;
    const className = constructor.prototype[Symbol.toStringTag];
    const valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name;
    if (className === valueClassName) {
      const stringifiedValue = inspect(value);
      throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
    }
  }
  return false;
};

// node_modules/graphql/language/source.mjs
var Source = class {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(false, "line in locationOffset is 1-indexed and must be positive.");
    this.locationOffset.column > 0 || devAssert(false, "column in locationOffset is 1-indexed and must be positive.");
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
};
function isSource(source) {
  return instanceOf(source, Source);
}

// node_modules/graphql/language/parser.mjs
function parse(source, options) {
  const parser = new Parser(source, options);
  return parser.parseDocument();
}
var Parser = class {
  constructor(source, options) {
    const sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
  }
  parseName() {
    const token = this.expectToken(TokenKind.NAME);
    return this.node(token, {
      kind: Kind.NAME,
      value: token.value
    });
  }
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF)
    });
  }
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are supported only on type definitions.");
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  parseVariableDefinitions() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
  }
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R)
    });
  }
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentDefinition() {
    var _this$_options;
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.allowLegacyFragmentVariables) === true) {
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  parseValueLiteral(isConst) {
    const token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this._lexer.advance();
        return this.node(token, {
          kind: Kind.INT,
          value: token.value
        });
      case TokenKind.FLOAT:
        this._lexer.advance();
        return this.node(token, {
          kind: Kind.FLOAT,
          value: token.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this._lexer.advance();
        switch (token.value) {
          case "true":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token, {
              kind: Kind.NULL
            });
          default:
            return this.node(token, {
              kind: Kind.ENUM,
              value: token.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(this._lexer.source, token.start, `Unexpected variable "$${varName}" in constant value.`);
          } else {
            throw this.unexpected(token);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token = this._lexer.token;
    this._lexer.advance();
    return this.node(token, {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING
    });
  }
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  parseTypeReference() {
    const start = this._lexer.token;
    let type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = this.node(start, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind.NON_NULL_TYPE,
        type
      });
    }
    return type;
  }
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    return this.node(start, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type = this.parseNamedType();
    return this.node(start, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type
    });
  }
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives
    });
  }
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  parseFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
  }
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type,
      directives
    });
  }
  parseArgumentDefs() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
  }
  parseInputValueDef() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type,
      defaultValue,
      directives
    });
  }
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types
    });
  }
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values
    });
  }
  parseEnumValuesDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
  }
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives
    });
  }
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);
    }
    return this.parseName();
  }
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields
    });
  }
  parseInputFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
  }
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives
    });
  }
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types
    });
  }
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values
    });
  }
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields
    });
  }
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations
    });
  }
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start);
  }
  node(startToken, node) {
    var _this$_options2;
    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.noLocation) !== true) {
      node.loc = new Location(startToken, this._lexer.lastToken, this._lexer.source);
    }
    return node;
  }
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  expectToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this._lexer.advance();
      return token;
    }
    throw syntaxError(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);
  }
  expectOptionalToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this._lexer.advance();
      return true;
    }
    return false;
  }
  expectKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this._lexer.advance();
    } else {
      throw syntaxError(this._lexer.source, token.start, `Expected "${value}", found ${getTokenDesc(token)}.`);
    }
  }
  expectOptionalKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this._lexer.advance();
      return true;
    }
    return false;
  }
  unexpected(atToken) {
    const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);
  }
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
};
function getTokenDesc(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}

// node_modules/wonka/dist/wonka.mjs
function l(a, b2) {
  b2.tag = a;
  return b2;
}
function m() {
}
function p(a) {
  return function(b2) {
    var c2 = a.length;
    let d2 = false, e = false, f2 = false, g = 0;
    b2(l(0, [
      function(h2) {
        if (h2) {
          d2 = true;
        } else if (e) {
          f2 = true;
        } else {
          for (e = f2 = true; f2 && !d2; ) {
            g < c2 ? (h2 = a[g], g = g + 1 | 0, f2 = false, b2(l(1, [h2]))) : (d2 = true, b2(0));
          }
          e = false;
        }
      }
    ]));
  };
}
function r() {
}
function t(a) {
  a(0);
}
function u(a) {
  let b2 = false;
  a(l(0, [
    function(c2) {
      c2 ? b2 = true : b2 || a(0);
    }
  ]));
}
function C(a) {
  return a(0);
}
function D(a) {
  return function(b2) {
    return function(c2) {
      let e = m, f2 = false, g = [], h2 = false;
      b2(function(b3) {
        typeof b3 == "number" ? h2 || (h2 = true, g.length === 0 && c2(0)) : b3.tag ? h2 || (f2 = false, function(a2) {
          function b4(a3) {
            typeof a3 == "number" ? g.length !== 0 && (g = g.filter(d2), a3 = g.length === 0, h2 && a3 ? c2(0) : !f2 && a3 && (f2 = true, e(0))) : a3.tag ? g.length !== 0 && (c2(l(1, [a3[0]])), k(0)) : (k = a3 = a3[0], g = g.concat(a3), a3(0));
          }
          function d2(a3) {
            return a3 !== k;
          }
          let k = m;
          a2.length === 1 ? a2(b4) : a2.bind(null, b4);
        }(a(b3[0])), f2 || (f2 = true, e(0))) : e = b3[0];
      });
      c2(l(0, [
        function(a2) {
          a2 ? (h2 || (h2 = true, e(a2)), g.forEach(function(c3) {
            return c3(a2);
          }), g = []) : (f2 || h2 ? f2 = false : (f2 = true, e(0)), g.forEach(C));
        }
      ]));
    };
  };
}
function E(a) {
  return a;
}
function H(a) {
  return function(b2) {
    return function(c2) {
      let d2 = false;
      return b2(function(e) {
        if (typeof e == "number") {
          d2 || (d2 = true, c2(e));
        } else if (e.tag) {
          d2 || (a(e[0]), c2(e));
        } else {
          var g = e[0];
          c2(l(0, [
            function(a2) {
              if (!d2) {
                return a2 && (d2 = true), g(a2);
              }
            }
          ]));
        }
      });
    };
  };
}
function J(a) {
  a(0);
}
function K(a) {
  return function(b2) {
    return function(c2) {
      function d2(a2) {
        h2 && (typeof a2 == "number" ? (h2 = false, n ? c2(a2) : f2 || (f2 = true, e(0))) : a2.tag ? (c2(a2), k ? k = false : g(0)) : (g = a2 = a2[0], k = false, a2(0)));
      }
      let e = m, f2 = false, g = m, h2 = false, k = false, n = false;
      b2(function(b3) {
        typeof b3 == "number" ? n || (n = true, h2 || c2(0)) : b3.tag ? n || (h2 && (g(1), g = m), f2 ? f2 = false : (f2 = true, e(0)), b3 = a(b3[0]), h2 = true, b3(d2)) : e = b3[0];
      });
      c2(l(0, [
        function(a2) {
          if (a2) {
            if (n || (n = true, e(1)), h2) {
              return h2 = false, g(1);
            }
          } else {
            n || f2 || (f2 = true, e(0)), h2 && !k && (k = true, g(0));
          }
        }
      ]));
    };
  };
}
function M(a) {
  return function(b2) {
    return function(c2) {
      let d2 = [], e = m;
      return b2(function(b3) {
        typeof b3 == "number" ? p(d2)(c2) : b3.tag ? (d2.length >= a && 0 < a && d2.shift(), d2.push(b3[0]), e(0)) : (b3 = b3[0], 0 >= a ? (b3(1), u(c2)) : (e = b3, b3(0)));
      });
    };
  };
}
function N(a) {
  return function(b2) {
    let c2 = m, d2 = false;
    b2(function(e) {
      typeof e == "number" ? d2 = true : e.tag ? d2 || (a(e[0]), c2(0)) : (c2 = e = e[0], e(0));
    });
    return {
      unsubscribe: function() {
        if (!d2) {
          return d2 = true, c2(1);
        }
      }
    };
  };
}
function O() {
}
function filter$1(a) {
  return function(b2) {
    return function(c2) {
      let d2 = m;
      return b2(function(b3) {
        typeof b3 == "number" ? c2(b3) : b3.tag ? a(b3[0]) ? c2(b3) : d2(0) : (d2 = b3[0], c2(b3));
      });
    };
  };
}
function fromValue$1(a) {
  return function(b2) {
    let c2 = false;
    b2(l(0, [
      function(d2) {
        d2 ? c2 = true : c2 || (c2 = true, b2(l(1, [a])), b2(0));
      }
    ]));
  };
}
function make$1(a) {
  return function(b2) {
    let c2 = r, d2 = false;
    c2 = a({
      next: function(a2) {
        d2 || b2(l(1, [a2]));
      },
      complete: function() {
        d2 || (d2 = true, b2(0));
      }
    });
    b2(l(0, [
      function(a2) {
        if (a2 && !d2) {
          return d2 = true, c2();
        }
      }
    ]));
  };
}
function makeSubject$1() {
  let a = [], b2 = false;
  return {
    source: function(c2) {
      function b3(a2) {
        return a2 !== c2;
      }
      a = a.concat(c2);
      c2(l(0, [
        function(c3) {
          c3 && (a = a.filter(b3));
        }
      ]));
    },
    next: function(c2) {
      b2 || a.forEach(function(a2) {
        a2(l(1, [c2]));
      });
    },
    complete: function() {
      b2 || (b2 = true, a.forEach(t));
    }
  };
}
function map$1(a) {
  return function(b2) {
    return function(c2) {
      return b2(function(b3) {
        b3 = typeof b3 == "number" ? 0 : b3.tag ? l(1, [a(b3[0])]) : l(0, [b3[0]]);
        c2(b3);
      });
    };
  };
}
function merge$1(a) {
  return D(E)(p(a));
}
function onEnd$1(a) {
  return function(b2) {
    return function(c2) {
      let d2 = false;
      return b2(function(b3) {
        if (typeof b3 == "number") {
          if (d2) {
            return;
          }
          d2 = true;
          c2(b3);
          return a();
        }
        if (b3.tag) {
          d2 || c2(b3);
        } else {
          var e = b3[0];
          c2(l(0, [
            function(c3) {
              if (!d2) {
                return c3 ? (d2 = true, e(c3), a()) : e(c3);
              }
            }
          ]));
        }
      });
    };
  };
}
function onStart$1(a) {
  return function(b2) {
    return function(c2) {
      return b2(function(b3) {
        typeof b3 == "number" ? c2(b3) : b3.tag ? c2(b3) : (c2(b3), a());
      });
    };
  };
}
function publish$1(a) {
  return N(O)(a);
}
function share$1(a) {
  function b2(a2) {
    typeof a2 == "number" ? (c2.forEach(J), c2 = []) : a2.tag ? (e = false, c2.forEach(function(b3) {
      b3(a2);
    })) : d2 = a2[0];
  }
  let c2 = [], d2 = m, e = false;
  return function(f2) {
    function g(a2) {
      return a2 !== f2;
    }
    c2 = c2.concat(f2);
    c2.length === 1 && a(b2);
    f2(l(0, [
      function(a2) {
        if (a2) {
          if (c2 = c2.filter(g), c2.length === 0) {
            return d2(1);
          }
        } else {
          e || (e = true, d2(a2));
        }
      }
    ]));
  };
}
function take$1(a) {
  return function(b2) {
    return function(c2) {
      let d2 = false, e = 0, f2 = m;
      b2(function(b3) {
        typeof b3 == "number" ? d2 || (d2 = true, c2(0)) : b3.tag ? e < a && !d2 && (e = e + 1 | 0, c2(b3), !d2 && e >= a && (d2 = true, c2(0), f2(1))) : (b3 = b3[0], 0 >= a ? (d2 = true, c2(0), b3(1)) : f2 = b3);
      });
      c2(l(0, [
        function(b3) {
          if (!d2) {
            if (b3) {
              return d2 = true, f2(1);
            }
            if (e < a) {
              return f2(0);
            }
          }
        }
      ]));
    };
  };
}
function takeUntil$1(a) {
  return function(b2) {
    return function(c2) {
      function d2(a2) {
        typeof a2 != "number" && (a2.tag ? (e = true, f2(1), c2(0)) : (g = a2 = a2[0], a2(0)));
      }
      let e = false, f2 = m, g = m;
      b2(function(b3) {
        typeof b3 == "number" ? e || (e = true, g(1), c2(0)) : b3.tag ? e || c2(b3) : (f2 = b3[0], a(d2));
      });
      c2(l(0, [
        function(a2) {
          if (!e) {
            return a2 ? (e = true, f2(1), g(1)) : f2(0);
          }
        }
      ]));
    };
  };
}
function toPromise$1(a) {
  return new Promise(function(b2) {
    M(1)(a)(function(a2) {
      if (typeof a2 != "number") {
        if (a2.tag) {
          b2(a2[0]);
        } else {
          a2[0](0);
        }
      }
    });
  });
}
var P = typeof Symbol == "function" ? Symbol.observable || (Symbol.observable = Symbol("observable")) : "@@observable";

// node_modules/@urql/core/dist/ab6c3355.mjs
function rehydrateGraphQlError(r2) {
  if (typeof r2 == "string") {
    return new GraphQLError(r2);
  } else if (typeof r2 == "object" && r2.message) {
    return new GraphQLError(r2.message, r2.nodes, r2.source, r2.positions, r2.path, r2, r2.extensions || {});
  } else {
    return r2;
  }
}
var o = function(e) {
  function CombinedError(r2) {
    var t2 = r2.networkError;
    var n = r2.response;
    var a = (r2.graphQLErrors || []).map(rehydrateGraphQlError);
    var o2 = function generateErrorMessage(e2, r3) {
      var t3 = "";
      if (e2 !== void 0) {
        return t3 = "[Network] " + e2.message;
      }
      if (r3 !== void 0) {
        r3.forEach(function(e3) {
          t3 += "[GraphQL] " + e3.message + "\n";
        });
      }
      return t3.trim();
    }(t2, a);
    e.call(this, o2);
    this.name = "CombinedError";
    this.message = o2;
    this.graphQLErrors = a;
    this.networkError = t2;
    this.response = n;
  }
  if (e) {
    CombinedError.__proto__ = e;
  }
  (CombinedError.prototype = Object.create(e && e.prototype)).constructor = CombinedError;
  CombinedError.prototype.toString = function toString() {
    return this.message;
  };
  return CombinedError;
}(Error);
function phash(e, r2) {
  e |= 0;
  for (var t2 = 0, n = 0 | r2.length; t2 < n; t2++) {
    e = (e << 5) + e + r2.charCodeAt(t2);
  }
  return e;
}
function hash(e) {
  return phash(5381, e) >>> 0;
}
var i = /* @__PURE__ */ new Set();
var s = /* @__PURE__ */ new WeakMap();
function stringify(e) {
  if (e === null || i.has(e)) {
    return "null";
  } else if (typeof e != "object") {
    return JSON.stringify(e) || "";
  } else if (e.toJSON) {
    return stringify(e.toJSON());
  } else if (Array.isArray(e)) {
    var r2 = "[";
    for (var t2 = 0, n = e.length; t2 < n; t2++) {
      if (t2 > 0) {
        r2 += ",";
      }
      var a = stringify(e[t2]);
      r2 += a.length > 0 ? a : "null";
    }
    return r2 += "]";
  }
  var o2 = Object.keys(e).sort();
  if (!o2.length && e.constructor && e.constructor !== Object) {
    var u3 = s.get(e) || Math.random().toString(36).slice(2);
    s.set(e, u3);
    return '{"__key":"' + u3 + '"}';
  }
  i.add(e);
  var f2 = "{";
  for (var c2 = 0, l3 = o2.length; c2 < l3; c2++) {
    var p3 = o2[c2];
    var h2 = stringify(e[p3]);
    if (h2) {
      if (f2.length > 1) {
        f2 += ",";
      }
      f2 += stringify(p3) + ":" + h2;
    }
  }
  i.delete(e);
  return f2 += "}";
}
function stringifyVariables(e) {
  i.clear();
  return stringify(e);
}
var u2 = /("{3}[\s\S]*"{3}|"(?:\\.|[^"])*")/g;
var f = /([\s,]|#[^\n\r]+)+/g;
function replaceOutsideStrings(e, r2) {
  return r2 % 2 == 0 ? e.replace(f, " ").trim() : e;
}
function stringifyDocument(e) {
  var r2 = (typeof e != "string" ? e.loc && e.loc.source.body || print(e) : e).split(u2).map(replaceOutsideStrings).join("");
  if (typeof e != "string") {
    var t2 = "definitions" in e && getOperationName(e);
    if (t2) {
      r2 = "# " + t2 + "\n" + r2;
    }
    if (!e.loc) {
      e.loc = {
        start: 0,
        end: r2.length,
        source: {
          body: r2,
          name: "gql",
          locationOffset: {
            line: 1,
            column: 1
          }
        }
      };
    }
  }
  return r2;
}
var c = /* @__PURE__ */ new Map();
function keyDocument(e) {
  var r2;
  var n;
  if (typeof e == "string") {
    r2 = hash(stringifyDocument(e));
    n = c.get(r2) || parse(e, {
      noLocation: true
    });
  } else {
    r2 = e.__key || hash(stringifyDocument(e));
    n = c.get(r2) || e;
  }
  if (!n.loc) {
    stringifyDocument(n);
  }
  n.__key = r2;
  c.set(r2, n);
  return n;
}
function createRequest(e, r2) {
  if (!r2) {
    r2 = {};
  }
  var t2 = keyDocument(e);
  return {
    key: phash(t2.__key, stringifyVariables(r2)) >>> 0,
    query: t2,
    variables: r2
  };
}
function getOperationName(e) {
  for (var t2 = 0, n = e.definitions.length; t2 < n; t2++) {
    var a = e.definitions[t2];
    if (a.kind === Kind.OPERATION_DEFINITION && a.name) {
      return a.name.value;
    }
  }
}
function getOperationType(e) {
  for (var t2 = 0, n = e.definitions.length; t2 < n; t2++) {
    var a = e.definitions[t2];
    if (a.kind === Kind.OPERATION_DEFINITION) {
      return a.operation;
    }
  }
}
function _extends() {
  return (_extends = Object.assign || function(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = arguments[r2];
      for (var n in t2) {
        if (Object.prototype.hasOwnProperty.call(t2, n)) {
          e[n] = t2[n];
        }
      }
    }
    return e;
  }).apply(this, arguments);
}
function makeResult(e, r2, t2) {
  if (!("data" in r2) && !("errors" in r2) || "path" in r2) {
    throw new Error("No Content");
  }
  return {
    operation: e,
    data: r2.data,
    error: Array.isArray(r2.errors) ? new o({
      graphQLErrors: r2.errors,
      response: t2
    }) : void 0,
    extensions: typeof r2.extensions == "object" && r2.extensions || void 0,
    hasNext: !!r2.hasNext
  };
}
function mergeResultPatch(e, r2, t2) {
  var n = _extends({}, e);
  n.hasNext = !!r2.hasNext;
  if (!("path" in r2)) {
    if ("data" in r2) {
      n.data = r2.data;
    }
    return n;
  }
  if (Array.isArray(r2.errors)) {
    n.error = new o({
      graphQLErrors: n.error ? n.error.graphQLErrors.concat(r2.errors) : r2.errors,
      response: t2
    });
  }
  var a = n.data = _extends({}, n.data);
  var i2 = 0;
  var s2;
  while (i2 < r2.path.length) {
    a = a[s2 = r2.path[i2++]] = Array.isArray(a[s2]) ? [].concat(a[s2]) : _extends({}, a[s2]);
  }
  _extends(a, r2.data);
  return n;
}
function makeErrorResult(e, r2, t2) {
  return {
    operation: e,
    data: void 0,
    error: new o({
      networkError: r2,
      response: t2
    }),
    extensions: void 0
  };
}
function shouldUseGet(e) {
  return e.kind === "query" && !!e.context.preferGetMethod;
}
function makeFetchBody(e) {
  return {
    query: print(e.query),
    operationName: getOperationName(e.query),
    variables: e.variables || void 0,
    extensions: void 0
  };
}
function makeFetchURL(e, r2) {
  var t2 = shouldUseGet(e);
  var n = e.context.url;
  if (!t2 || !r2) {
    return n;
  }
  var a = [];
  if (r2.operationName) {
    a.push("operationName=" + encodeURIComponent(r2.operationName));
  }
  if (r2.query) {
    a.push("query=" + encodeURIComponent(r2.query.replace(/#[^\n\r]+/g, " ").trim()));
  }
  if (r2.variables) {
    a.push("variables=" + encodeURIComponent(stringifyVariables(r2.variables)));
  }
  if (r2.extensions) {
    a.push("extensions=" + encodeURIComponent(stringifyVariables(r2.extensions)));
  }
  var o2 = n + "?" + a.join("&");
  if (o2.length > 2047) {
    e.context.preferGetMethod = false;
    return n;
  }
  return o2;
}
function makeFetchOptions(e, r2) {
  var t2 = shouldUseGet(e);
  var n = {
    accept: "application/graphql+json, application/json"
  };
  if (!t2) {
    n["content-type"] = "application/json";
  }
  var a = (typeof e.context.fetchOptions == "function" ? e.context.fetchOptions() : e.context.fetchOptions) || {};
  if (a.headers) {
    for (var o2 in a.headers) {
      n[o2.toLowerCase()] = a.headers[o2];
    }
  }
  return _extends({}, a, {
    body: !t2 && r2 ? JSON.stringify(r2) : void 0,
    method: t2 ? "GET" : "POST",
    headers: n
  });
}
var l2 = typeof Symbol != "undefined" ? Symbol.asyncIterator : null;
var p2 = typeof TextDecoder != "undefined" ? new TextDecoder() : null;
var h = /content-type:[^\r\n]*application\/json/i;
var d = /boundary="?([^=";]+)"?/i;
function makeFetchSource(e, r2, t2) {
  var n = t2.redirect === "manual" ? 400 : 300;
  var o2 = e.context.fetch;
  return make$1(function(a) {
    var i2 = a.next;
    var s2 = a.complete;
    var u3 = typeof AbortController != "undefined" ? new AbortController() : null;
    if (u3) {
      t2.signal = u3.signal;
    }
    var f2 = false;
    function executeIncrementalFetch(e2, r3, t3) {
      var n2 = t3.headers && t3.headers.get("Content-Type") || "";
      if (/text\//i.test(n2)) {
        return t3.text().then(function(n3) {
          e2(makeErrorResult(r3, new Error(n3), t3));
        });
      } else if (!/multipart\/mixed/i.test(n2)) {
        return t3.text().then(function(n3) {
          e2(makeResult(r3, JSON.parse(n3), t3));
        });
      }
      var a2 = "---";
      var o3 = n2.match(d);
      if (o3) {
        a2 = "--" + o3[1];
      }
      var i3;
      var cancel = function() {
      };
      if (l2 && t3[l2]) {
        var s3 = t3[l2]();
        i3 = s3.next.bind(s3);
      } else if ("body" in t3 && t3.body) {
        var u4 = t3.body.getReader();
        cancel = u4.cancel.bind(u4);
        i3 = u4.read.bind(u4);
      } else {
        throw new TypeError("Streaming requests unsupported");
      }
      var c3 = "";
      var v2 = true;
      var m3 = null;
      var g = null;
      return i3().then(function next(n3) {
        if (!n3.done) {
          var o4 = function toString(e3) {
            return e3.constructor.name === "Buffer" ? e3.toString() : p2.decode(e3);
          }(n3.value);
          var s4 = o4.indexOf(a2);
          if (s4 > -1) {
            s4 += c3.length;
          } else {
            s4 = c3.indexOf(a2);
          }
          c3 += o4;
          while (s4 > -1) {
            var u5 = c3.slice(0, s4);
            var l3 = c3.slice(s4 + a2.length);
            if (v2) {
              v2 = false;
            } else {
              var d2 = u5.indexOf("\r\n\r\n") + 4;
              var y2 = u5.slice(0, d2);
              var x = u5.slice(d2, u5.lastIndexOf("\r\n"));
              var b2 = void 0;
              if (h.test(y2)) {
                try {
                  b2 = JSON.parse(x);
                  m3 = g = g ? mergeResultPatch(g, b2, t3) : makeResult(r3, b2, t3);
                } catch (e3) {
                }
              }
              if (l3.slice(0, 2) === "--" || b2 && !b2.hasNext) {
                if (!g) {
                  return e2(makeResult(r3, {}, t3));
                }
                break;
              }
            }
            s4 = (c3 = l3).indexOf(a2);
          }
        } else {
          f2 = true;
        }
        if (m3) {
          e2(m3);
          m3 = null;
        }
        if (!n3.done && (!g || g.hasNext)) {
          return i3().then(next);
        }
      }).finally(cancel);
    }
    var c2 = false;
    var v = false;
    var m2;
    Promise.resolve().then(function() {
      if (c2) {
        return;
      }
      return (o2 || fetch)(r2, t2);
    }).then(function(r3) {
      if (!r3) {
        return;
      }
      v = (m2 = r3).status < 200 || m2.status >= n;
      return executeIncrementalFetch(i2, e, m2);
    }).then(s2).catch(function(r3) {
      if (f2) {
        throw r3;
      }
      var t3 = makeErrorResult(e, v ? m2.statusText ? new Error(m2.statusText) : r3 : r3, m2);
      i2(t3);
      s2();
    });
    return function() {
      c2 = true;
      if (u3) {
        u3.abort();
      }
    };
  });
}

// node_modules/@urql/core/dist/urql-core.mjs
function collectTypes(e, n) {
  if (Array.isArray(e)) {
    for (var r2 = 0; r2 < e.length; r2++) {
      collectTypes(e[r2], n);
    }
  } else if (typeof e == "object" && e !== null) {
    for (var t2 in e) {
      if (t2 === "__typename" && typeof e[t2] == "string") {
        n[e[t2]] = 0;
      } else {
        collectTypes(e[t2], n);
      }
    }
  }
  return n;
}
function collectTypesFromResponse(e) {
  return Object.keys(collectTypes(e, {}));
}
var formatNode = function(e) {
  if (e.selectionSet && !e.selectionSet.selections.some(function(e2) {
    return e2.kind === Kind.FIELD && e2.name.value === "__typename" && !e2.alias;
  })) {
    return _extends({}, e, {
      selectionSet: _extends({}, e.selectionSet, {
        selections: e.selectionSet.selections.concat([{
          kind: Kind.FIELD,
          name: {
            kind: Kind.NAME,
            value: "__typename"
          }
        }])
      })
    });
  }
};
var F = /* @__PURE__ */ new Map();
function formatDocument(n) {
  var r2 = keyDocument(n);
  var a = F.get(r2.__key);
  if (!a) {
    a = visit(r2, {
      Field: formatNode,
      InlineFragment: formatNode
    });
    Object.defineProperty(a, "__key", {
      value: r2.__key,
      enumerable: false
    });
    F.set(r2.__key, a);
  }
  return a;
}
function maskTypename(e) {
  if (!e || typeof e != "object") {
    return e;
  }
  return Object.keys(e).reduce(function(n, r2) {
    var t2 = e[r2];
    if (r2 === "__typename") {
      Object.defineProperty(n, "__typename", {
        enumerable: false,
        value: t2
      });
    } else if (Array.isArray(t2)) {
      n[r2] = t2.map(maskTypename);
    } else if (t2 && typeof t2 == "object" && "__typename" in t2) {
      n[r2] = maskTypename(t2);
    } else {
      n[r2] = t2;
    }
    return n;
  }, Array.isArray(e) ? [] : {});
}
function withPromise(e) {
  e.toPromise = function() {
    return new Promise(function(n) {
      var r2 = N(function(e2) {
        if (!e2.stale && !e2.hasNext) {
          Promise.resolve().then(function() {
            r2.unsubscribe();
            n(e2);
          });
        }
      })(e);
    });
  };
  return e;
}
function makeOperation(e, n, r2) {
  if (!r2) {
    r2 = n.context;
  }
  return {
    key: n.key,
    query: n.query,
    variables: n.variables,
    kind: e,
    context: r2
  };
}
function addMetadata(e, n) {
  return makeOperation(e.kind, e, _extends({}, e.context, {
    meta: _extends({}, e.context.meta, n)
  }));
}
function noop() {
}
function applyDefinitions(e, r2, t2) {
  for (var a = 0; a < t2.length; a++) {
    if (t2[a].kind === Kind.FRAGMENT_DEFINITION) {
      var o2 = t2[a].name.value;
      var i2 = stringifyDocument(t2[a]);
      if (!e.has(o2)) {
        e.set(o2, i2);
        r2.push(t2[a]);
      } else if (e.get(o2) !== i2) {
        console.warn("[WARNING: Duplicate Fragment] A fragment with name `" + o2 + "` already exists in this document.\nWhile fragment names may not be unique across your source, each name must be unique per document.");
      }
    } else {
      r2.push(t2[a]);
    }
  }
}
function gql() {
  var e = arguments;
  var r2 = /* @__PURE__ */ new Map();
  var a = [];
  var o2 = [];
  var i2 = Array.isArray(arguments[0]) ? arguments[0][0] : arguments[0] || "";
  for (var u3 = 1; u3 < arguments.length; u3++) {
    var c2 = e[u3];
    if (c2 && c2.definitions) {
      o2.push.apply(o2, c2.definitions);
    } else {
      i2 += c2;
    }
    i2 += e[0][u3];
  }
  applyDefinitions(r2, a, keyDocument(i2).definitions);
  applyDefinitions(r2, a, o2);
  return keyDocument({
    kind: Kind.DOCUMENT,
    definitions: a
  });
}
function shouldSkip(e) {
  var n = e.kind;
  return n !== "mutation" && n !== "query";
}
function cacheExchange(e) {
  var n = e.forward;
  var r2 = e.client;
  var t2 = e.dispatchDebug;
  var a = /* @__PURE__ */ new Map();
  var i2 = /* @__PURE__ */ Object.create(null);
  function mapTypeNames(e2) {
    var n2 = makeOperation(e2.kind, e2);
    n2.query = formatDocument(e2.query);
    return n2;
  }
  function isOperationCached(e2) {
    var n2 = e2.context.requestPolicy;
    return e2.kind === "query" && n2 !== "network-only" && (n2 === "cache-only" || a.has(e2.key));
  }
  return function(e2) {
    var u3 = share$1(e2);
    var c2 = map$1(function(e3) {
      var n2 = a.get(e3.key);
      t2(_extends({}, {
        operation: e3
      }, n2 ? {
        type: "cacheHit",
        message: "The result was successfully retried from the cache"
      } : {
        type: "cacheMiss",
        message: "The result could not be retrieved from the cache"
      }));
      var i3 = _extends({}, n2, {
        operation: addMetadata(e3, {
          cacheOutcome: n2 ? "hit" : "miss"
        })
      });
      if (e3.context.requestPolicy === "cache-and-network") {
        i3.stale = true;
        reexecuteOperation(r2, e3);
      }
      return i3;
    })(filter$1(function(e3) {
      return !shouldSkip(e3) && isOperationCached(e3);
    })(u3));
    var s2 = H(function(e3) {
      var n2 = e3.operation;
      if (!n2) {
        return;
      }
      var o2 = collectTypesFromResponse(e3.data).concat(n2.context.additionalTypenames || []);
      if (e3.operation.kind === "mutation") {
        var u4 = /* @__PURE__ */ new Set();
        t2({
          type: "cacheInvalidation",
          message: "The following typenames have been invalidated: " + o2,
          operation: n2,
          data: {
            typenames: o2,
            response: e3
          },
          source: "cacheExchange"
        });
        for (var c3 = 0; c3 < o2.length; c3++) {
          var s3 = o2[c3];
          var f2 = i2[s3] || (i2[s3] = /* @__PURE__ */ new Set());
          f2.forEach(function(e4) {
            u4.add(e4);
          });
          f2.clear();
        }
        u4.forEach(function(e4) {
          if (a.has(e4)) {
            n2 = a.get(e4).operation;
            a.delete(e4);
            reexecuteOperation(r2, n2);
          }
        });
      } else if (n2.kind === "query" && e3.data) {
        a.set(n2.key, e3);
        for (var p3 = 0; p3 < o2.length; p3++) {
          var l3 = o2[p3];
          (i2[l3] || (i2[l3] = /* @__PURE__ */ new Set())).add(n2.key);
        }
      }
    })(n(filter$1(function(e3) {
      return e3.kind !== "query" || e3.context.requestPolicy !== "cache-only";
    })(map$1(function(e3) {
      return addMetadata(e3, {
        cacheOutcome: "miss"
      });
    })(merge$1([map$1(mapTypeNames)(filter$1(function(e3) {
      return !shouldSkip(e3) && !isOperationCached(e3);
    })(u3)), filter$1(function(e3) {
      return shouldSkip(e3);
    })(u3)])))));
    return merge$1([c2, s2]);
  };
}
function reexecuteOperation(e, n) {
  return e.reexecuteOperation(makeOperation(n.kind, n, _extends({}, n.context, {
    requestPolicy: "network-only"
  })));
}
var Q = /* @__PURE__ */ new Set();
function ssrExchange(e) {
  var n = !(!e || !e.staleWhileRevalidate);
  var r2 = !(!e || !e.includeExtensions);
  var t2 = {};
  var a = [];
  function invalidate(e2) {
    a.push(e2.operation.key);
    if (a.length === 1) {
      Promise.resolve().then(function() {
        var e3;
        while (e3 = a.shift()) {
          t2[e3] = null;
        }
      });
    }
  }
  var ssr = function(a2) {
    var o2 = a2.client;
    var i2 = a2.forward;
    return function(a3) {
      var u3 = e && typeof e.isClient == "boolean" ? !!e.isClient : !o2.suspense;
      var s2 = share$1(a3);
      var f2 = i2(filter$1(function(e2) {
        return !t2[e2.key] || !!t2[e2.key].hasNext;
      })(s2));
      var p3 = map$1(function(e2) {
        var a4 = function deserializeResult(e3, n2, r3) {
          return {
            operation: e3,
            data: n2.data ? JSON.parse(n2.data) : void 0,
            extensions: r3 && n2.extensions ? JSON.parse(n2.extensions) : void 0,
            error: n2.error ? new o({
              networkError: n2.error.networkError ? new Error(n2.error.networkError) : void 0,
              graphQLErrors: n2.error.graphQLErrors
            }) : void 0,
            hasNext: n2.hasNext
          };
        }(e2, t2[e2.key], r2);
        if (n && !Q.has(e2.key)) {
          a4.stale = true;
          Q.add(e2.key);
          reexecuteOperation(o2, e2);
        }
        return a4;
      })(filter$1(function(e2) {
        return !!t2[e2.key] && e2.context.requestPolicy !== "network-only";
      })(s2));
      if (!u3) {
        f2 = H(function(e2) {
          var n2 = e2.operation;
          if (n2.kind !== "mutation") {
            var a4 = function serializeResult(e3, n3) {
              var r3 = e3.hasNext;
              var t3 = e3.data;
              var a5 = e3.extensions;
              var o3 = e3.error;
              var i3 = {};
              if (t3 !== void 0) {
                i3.data = JSON.stringify(t3);
              }
              if (n3 && a5 !== void 0) {
                i3.extensions = JSON.stringify(a5);
              }
              if (r3) {
                i3.hasNext = true;
              }
              if (o3) {
                i3.error = {
                  graphQLErrors: o3.graphQLErrors.map(function(e4) {
                    if (!e4.path && !e4.extensions) {
                      return e4.message;
                    }
                    return {
                      message: e4.message,
                      path: e4.path,
                      extensions: e4.extensions
                    };
                  })
                };
                if (o3.networkError) {
                  i3.error.networkError = "" + o3.networkError;
                }
              }
              return i3;
            }(e2, r2);
            t2[n2.key] = a4;
          }
        })(f2);
      } else {
        p3 = H(invalidate)(p3);
      }
      return merge$1([f2, p3]);
    };
  };
  ssr.restoreData = function(e2) {
    for (var n2 in e2) {
      if (t2[n2] !== null) {
        t2[n2] = e2[n2];
      }
    }
  };
  ssr.extractData = function() {
    var e2 = {};
    for (var n2 in t2) {
      if (t2[n2] != null) {
        e2[n2] = t2[n2];
      }
    }
    return e2;
  };
  if (e && e.initialState) {
    ssr.restoreData(e.initialState);
  }
  return ssr;
}
function subscriptionExchange(e) {
  var n = e.forwardSubscription;
  var t2 = e.enableAllOperations;
  return function(e2) {
    var a = e2.client;
    var i2 = e2.forward;
    function isSubscriptionOperation(e3) {
      var n2 = e3.kind;
      return n2 === "subscription" || !!t2 && (n2 === "query" || n2 === "mutation");
    }
    return function(e3) {
      var t3 = share$1(e3);
      var u3 = D(function(e4) {
        var i3 = e4.key;
        var u4 = filter$1(function(e5) {
          return e5.kind === "teardown" && e5.key === i3;
        })(t3);
        return takeUntil$1(u4)(function createSubscriptionSource(e5) {
          var t4 = n({
            key: e5.key.toString(36),
            query: print(e5.query),
            variables: e5.variables,
            context: _extends({}, e5.context)
          });
          return make$1(function(n2) {
            var r2 = n2.next;
            var o2 = n2.complete;
            var i4 = false;
            var u5;
            Promise.resolve().then(function() {
              if (i4) {
                return;
              }
              u5 = t4.subscribe({
                next: function(n3) {
                  return r2(makeResult(e5, n3));
                },
                error: function(n3) {
                  return r2(makeErrorResult(e5, n3));
                },
                complete: function() {
                  if (!i4) {
                    i4 = true;
                    if (e5.kind === "subscription") {
                      a.reexecuteOperation(makeOperation("teardown", e5, e5.context));
                    }
                    o2();
                  }
                }
              });
            });
            return function() {
              i4 = true;
              if (u5) {
                u5.unsubscribe();
              }
            };
          });
        }(e4));
      })(filter$1(isSubscriptionOperation)(t3));
      var c2 = i2(filter$1(function(e4) {
        return !isSubscriptionOperation(e4);
      })(t3));
      return merge$1([u3, c2]);
    };
  };
}
function debugExchange(e) {
  var n = e.forward;
  if (false) {
    return function(e2) {
      return n(e2);
    };
  } else {
    return function(e2) {
      return H(function(e3) {
        return console.log("[Exchange debug]: Completed operation: ", e3);
      })(n(H(function(e3) {
        return console.log("[Exchange debug]: Incoming operation: ", e3);
      })(e2)));
    };
  }
}
function dedupExchange(e) {
  var n = e.forward;
  var r2 = e.dispatchDebug;
  var t2 = /* @__PURE__ */ new Set();
  function filterIncomingOperation(e2) {
    var n2 = e2.key;
    var a = e2.kind;
    if (a === "teardown") {
      t2.delete(n2);
      return true;
    }
    if (a !== "query" && a !== "subscription") {
      return true;
    }
    var o2 = t2.has(n2);
    t2.add(n2);
    if (o2) {
      r2({
        type: "dedup",
        message: "An operation has been deduped.",
        operation: e2,
        source: "dedupExchange"
      });
    }
    return !o2;
  }
  function afterOperationResult(e2) {
    if (!e2.hasNext) {
      t2.delete(e2.operation.key);
    }
  }
  return function(e2) {
    var r3 = filter$1(filterIncomingOperation)(e2);
    return H(afterOperationResult)(n(r3));
  };
}
function fetchExchange(e) {
  var n = e.forward;
  var r2 = e.dispatchDebug;
  return function(e2) {
    var t2 = share$1(e2);
    var a = D(function(e3) {
      var n2 = e3.key;
      var a2 = filter$1(function(e4) {
        return e4.kind === "teardown" && e4.key === n2;
      })(t2);
      var o3 = makeFetchBody(e3);
      var i2 = makeFetchURL(e3, o3);
      var u3 = makeFetchOptions(e3, o3);
      r2({
        type: "fetchRequest",
        message: "A fetch request is being executed.",
        operation: e3,
        data: {
          url: i2,
          fetchOptions: u3
        },
        source: "fetchExchange"
      });
      return H(function(n3) {
        var t3 = !n3.data ? n3.error : void 0;
        r2({
          type: t3 ? "fetchError" : "fetchSuccess",
          message: "A " + (t3 ? "failed" : "successful") + " fetch response has been returned.",
          operation: e3,
          data: {
            url: i2,
            fetchOptions: u3,
            value: t3 || n3
          },
          source: "fetchExchange"
        });
      })(takeUntil$1(a2)(makeFetchSource(e3, i2, u3)));
    })(filter$1(function(e3) {
      return e3.kind === "query" || e3.kind === "mutation";
    })(t2));
    var o2 = n(filter$1(function(e3) {
      return e3.kind !== "query" && e3.kind !== "mutation";
    })(t2));
    return merge$1([a, o2]);
  };
}
function fallbackExchange(e) {
  var n = e.dispatchDebug;
  return function(e2) {
    return filter$1(function() {
      return false;
    })(H(function(e3) {
      if (e3.kind !== "teardown" && true) {
        var r2 = 'No exchange has handled operations of kind "' + e3.kind + `". Check whether you've added an exchange responsible for these operations.`;
        n({
          type: "fallbackCatch",
          message: r2,
          operation: e3,
          source: "fallbackExchange"
        });
        console.warn(r2);
      }
    })(e2));
  };
}
var G = fallbackExchange({
  dispatchDebug: noop
});
function composeExchanges(e) {
  return function(n) {
    var r2 = n.client;
    var t2 = n.dispatchDebug;
    return e.reduceRight(function(e2, n2) {
      return n2({
        client: r2,
        forward: e2,
        dispatchDebug: function dispatchDebug$1(e3) {
          t2(_extends({}, {
            timestamp: Date.now(),
            source: n2.name
          }, e3));
        }
      });
    }, n.forward);
  };
}
function errorExchange(e) {
  var n = e.onError;
  return function(e2) {
    var r2 = e2.forward;
    return function(e3) {
      return H(function(e4) {
        var r3 = e4.error;
        if (r3) {
          n(r3, e4.operation);
        }
      })(r2(e3));
    };
  };
}
var L = [dedupExchange, cacheExchange, fetchExchange];
var J2 = function Client(e) {
  if (!e.url) {
    throw new Error("You are creating an urql-client without a url.");
  }
  var n = /* @__PURE__ */ new Map();
  var r2 = /* @__PURE__ */ new Map();
  var t2 = [];
  var a = makeSubject$1();
  var i2 = a.source;
  var u3 = a.next;
  var c2 = false;
  function dispatchOperation(e2) {
    c2 = true;
    if (e2) {
      u3(e2);
    }
    while (e2 = t2.shift()) {
      u3(e2);
    }
    c2 = false;
  }
  function makeResultSource(e2) {
    var a2 = filter$1(function(n2) {
      return n2.operation.kind === e2.kind && n2.operation.key === e2.key && (!n2.operation.context._instance || n2.operation.context._instance === e2.context._instance);
    })(y2);
    if (f2.maskTypename) {
      a2 = map$1(function(e3) {
        return _extends({}, e3, {
          data: maskTypename(e3.data)
        });
      })(a2);
    }
    if (e2.kind === "mutation") {
      return take$1(1)(onStart$1(function() {
        return dispatchOperation(e2);
      })(a2));
    }
    return share$1(onEnd$1(function() {
      n.delete(e2.key);
      r2.delete(e2.key);
      for (var a3 = t2.length - 1; a3 >= 0; a3--) {
        if (t2[a3].key === e2.key) {
          t2.splice(a3, 1);
        }
      }
      dispatchOperation(makeOperation("teardown", e2, e2.context));
    })(H(function(r3) {
      n.set(e2.key, r3);
    })(K(function(n2) {
      if (e2.kind !== "query" || n2.stale) {
        return fromValue$1(n2);
      }
      return merge$1([fromValue$1(n2), map$1(function() {
        return _extends({}, n2, {
          stale: true
        });
      })(take$1(1)(filter$1(function(n3) {
        return n3.kind === "query" && n3.key === e2.key && n3.context.requestPolicy !== "cache-only";
      })(i2)))]);
    })(takeUntil$1(filter$1(function(n2) {
      return n2.kind === "teardown" && n2.key === e2.key;
    })(i2))(a2)))));
  }
  var s2 = this instanceof Client ? this : Object.create(Client.prototype);
  var f2 = _extends(s2, {
    url: e.url,
    fetchOptions: e.fetchOptions,
    fetch: e.fetch,
    suspense: !!e.suspense,
    requestPolicy: e.requestPolicy || "cache-first",
    preferGetMethod: !!e.preferGetMethod,
    maskTypename: !!e.maskTypename,
    operations$: i2,
    reexecuteOperation: function reexecuteOperation2(e2) {
      if (e2.kind === "mutation" || r2.has(e2.key)) {
        t2.push(e2);
        if (!c2) {
          Promise.resolve().then(dispatchOperation);
        }
      }
    },
    createOperationContext: function createOperationContext(e2) {
      if (!e2) {
        e2 = {};
      }
      return _extends({}, {
        _instance: void 0,
        url: f2.url,
        fetchOptions: f2.fetchOptions,
        fetch: f2.fetch,
        preferGetMethod: f2.preferGetMethod
      }, e2, {
        suspense: e2.suspense || e2.suspense !== false && f2.suspense,
        requestPolicy: e2.requestPolicy || f2.requestPolicy
      });
    },
    createRequestOperation: function createRequestOperation(e2, n2, r3) {
      var t3 = getOperationType(n2.query);
      if (e2 !== "teardown" && t3 !== e2) {
        throw new Error('Expected operation of type "' + e2 + '" but found "' + t3 + '"');
      }
      var a2 = f2.createOperationContext(r3);
      if (e2 === "mutation") {
        a2._instance = [];
      }
      return makeOperation(e2, n2, a2);
    },
    executeRequestOperation: function executeRequestOperation(e2) {
      if (e2.kind === "mutation") {
        return makeResultSource(e2);
      }
      return make$1(function(t3) {
        var a2 = r2.get(e2.key);
        if (!a2) {
          r2.set(e2.key, a2 = makeResultSource(e2));
        }
        var i3 = e2.context.requestPolicy === "cache-and-network" || e2.context.requestPolicy === "network-only";
        return N(t3.next)(onEnd$1(t3.complete)(onStart$1(function() {
          var r3 = n.get(e2.key);
          if (e2.kind === "subscription") {
            return dispatchOperation(e2);
          } else if (i3) {
            dispatchOperation(e2);
          }
          if (r3 != null && r3 === n.get(e2.key)) {
            t3.next(i3 ? _extends({}, r3, {
              stale: true
            }) : r3);
          } else if (!i3) {
            dispatchOperation(e2);
          }
        })(a2))).unsubscribe;
      });
    },
    executeQuery: function executeQuery(e2, n2) {
      var r3 = f2.createRequestOperation("query", e2, n2);
      return f2.executeRequestOperation(r3);
    },
    executeSubscription: function executeSubscription(e2, n2) {
      var r3 = f2.createRequestOperation("subscription", e2, n2);
      return f2.executeRequestOperation(r3);
    },
    executeMutation: function executeMutation(e2, n2) {
      var r3 = f2.createRequestOperation("mutation", e2, n2);
      return f2.executeRequestOperation(r3);
    },
    query: function query(e2, n2, r3) {
      if (!r3 || typeof r3.suspense != "boolean") {
        r3 = _extends({}, r3, {
          suspense: false
        });
      }
      return withPromise(f2.executeQuery(createRequest(e2, n2), r3));
    },
    readQuery: function readQuery(e2, n2, r3) {
      var t3 = null;
      N(function(e3) {
        t3 = e3;
      })(f2.query(e2, n2, r3)).unsubscribe();
      return t3;
    },
    subscription: function subscription(e2, n2, r3) {
      return f2.executeSubscription(createRequest(e2, n2), r3);
    },
    mutation: function mutation(e2, n2, r3) {
      return withPromise(f2.executeMutation(createRequest(e2, n2), r3));
    }
  });
  var p3 = noop;
  if (true) {
    var l3 = makeSubject$1();
    var d2 = l3.next;
    var v = l3.source;
    f2.subscribeToDebugTarget = function(e2) {
      return N(e2)(v);
    };
    p3 = d2;
  }
  var h2 = composeExchanges(e.exchanges !== void 0 ? e.exchanges : L);
  var y2 = share$1(h2({
    client: f2,
    dispatchDebug: p3,
    forward: fallbackExchange({
      dispatchDebug: p3
    })
  })(i2));
  publish$1(y2);
  return f2;
};
var W = J2;

// node_modules/@urql/vue/dist/urql-vue.mjs
function _extends2() {
  return (_extends2 = Object.assign || function(e) {
    for (var u3 = 1; u3 < arguments.length; u3++) {
      var n = arguments[u3];
      for (var r2 in n) {
        if (Object.prototype.hasOwnProperty.call(n, r2)) {
          e[r2] = n[r2];
        }
      }
    }
    return e;
  }).apply(this, arguments);
}
function provideClient(u3) {
  var a;
  if (!isRef(u3)) {
    a = ref(u3 instanceof J2 ? u3 : new J2(u3));
  } else {
    a = u3;
  }
  provide("$urql", a);
  return a.value;
}
function install(u3, t2) {
  var a;
  if (!isRef(t2)) {
    a = ref(t2 instanceof J2 ? t2 : new J2(t2));
  } else {
    a = t2;
  }
  u3.provide("$urql", a);
}
function useClient() {
  if (!getCurrentInstance()) {
    throw new Error("use* functions may only be called during the `setup()` or other lifecycle hooks.");
  }
  var e = inject("$urql");
  if (!e) {
    throw new Error("No urql Client was provided. Did you forget to install the plugin or call `provideClient` in a parent?");
  }
  return e;
}
function unwrapPossibleProxy(e) {
  return e && isRef(e) ? e.value : e;
}
var y = {
  flush: "pre"
};
function useQuery(e) {
  return callUseQuery(e);
}
function callUseQuery(e, t2, a) {
  if (t2 === void 0) {
    t2 = useClient();
  }
  if (a === void 0) {
    a = [];
  }
  var i2 = reactive(e);
  var l3 = ref();
  var v = ref(false);
  var p3 = ref(false);
  var d2 = ref();
  var b2 = ref();
  var h2 = ref();
  var x = isRef(e.pause) ? e.pause : ref(!!e.pause);
  var w = ref(createRequest(i2.query, unwrapPossibleProxy(i2.variables)));
  var P2 = ref();
  a.push(watchEffect(function() {
    var e2 = createRequest(i2.query, unwrapPossibleProxy(i2.variables));
    if (w.value.key !== e2.key) {
      w.value = e2;
    }
  }, y));
  a.push(watchEffect(function() {
    P2.value = !x.value ? t2.value.executeQuery(w.value, _extends2({}, {
      requestPolicy: i2.requestPolicy
    }, i2.context)) : void 0;
  }, y));
  var Q2 = {
    data: l3,
    stale: v,
    error: d2,
    operation: b2,
    extensions: h2,
    fetching: p3,
    isPaused: x,
    executeQuery: function executeQuery(e2) {
      var u3 = P2.value = t2.value.executeQuery(w.value, _extends2({}, {
        requestPolicy: i2.requestPolicy
      }, i2.context, e2));
      return _extends2({}, S, {
        then: function then(e3, n) {
          return new Promise(function(e4) {
            var n2 = false;
            var r2 = N(function() {
              if (!Q2.fetching.value && !Q2.stale.value) {
                if (r2) {
                  r2.unsubscribe();
                }
                n2 = true;
                e4(Q2);
              }
            })(u3);
            if (n2) {
              r2.unsubscribe();
            }
          }).then(e3, n);
        }
      });
    },
    pause: function pause() {
      x.value = true;
    },
    resume: function resume() {
      x.value = false;
    }
  };
  a.push(watchEffect(function(e2) {
    if (P2.value) {
      p3.value = true;
      v.value = false;
      e2(N(function(e3) {
        l3.value = e3.data;
        v.value = !!e3.stale;
        p3.value = false;
        d2.value = e3.error;
        b2.value = e3.operation;
        h2.value = e3.extensions;
      })(onEnd$1(function() {
        p3.value = false;
        v.value = false;
      })(P2.value)).unsubscribe);
    } else {
      p3.value = false;
      v.value = false;
    }
  }, {
    flush: "sync"
  }));
  var S = _extends2({}, Q2, {
    then: function then(e2, u3) {
      return new Promise(function(e3) {
        if (!P2.value) {
          return e3(Q2);
        }
        var u4 = false;
        var n = N(function() {
          if (!Q2.fetching.value && !Q2.stale.value) {
            if (n) {
              n.unsubscribe();
            }
            u4 = true;
            e3(Q2);
          }
        })(P2.value);
        if (u4) {
          n.unsubscribe();
        }
      }).then(e2, u3);
    }
  });
  return S;
}
function useMutation(e) {
  return callUseMutation(e);
}
function callUseMutation(e, n) {
  if (n === void 0) {
    n = useClient();
  }
  var t2 = ref();
  var a = ref(false);
  var i2 = ref(false);
  var o2 = ref();
  var s2 = ref();
  var l3 = ref();
  return {
    data: t2,
    stale: a,
    fetching: i2,
    error: o2,
    operation: s2,
    extensions: l3,
    executeMutation: function executeMutation(r2, v) {
      i2.value = true;
      return toPromise$1(take$1(1)(n.value.executeMutation(createRequest(e, unwrapPossibleProxy(r2)), v || {}))).then(function(e2) {
        t2.value = e2.data;
        a.value = !!e2.stale;
        i2.value = false;
        o2.value = e2.error;
        s2.value = e2.operation;
        l3.value = e2.extensions;
        return e2;
      });
    }
  };
}
var b = {
  flush: "pre"
};
function useSubscription(e, u3) {
  return callUseSubscription(e, u3);
}
function callUseSubscription(e, t2, a, i2) {
  if (a === void 0) {
    a = useClient();
  }
  if (i2 === void 0) {
    i2 = [];
  }
  var l3 = reactive(e);
  var v = ref();
  var p3 = ref(false);
  var d2 = ref(false);
  var y2 = ref();
  var h2 = ref();
  var x = ref();
  var w = ref(t2);
  var P2 = isRef(e.pause) ? e.pause : ref(!!e.pause);
  var Q2 = ref(createRequest(l3.query, unwrapPossibleProxy(l3.variables)));
  var S = ref();
  i2.push(watchEffect(function() {
    var e2 = createRequest(l3.query, unwrapPossibleProxy(l3.variables));
    if (Q2.value.key !== e2.key) {
      Q2.value = e2;
    }
  }, b));
  i2.push(watchEffect(function() {
    S.value = !P2.value ? a.value.executeSubscription(Q2.value, _extends2({}, l3.context)) : void 0;
  }, b));
  i2.push(watchEffect(function(e2) {
    if (S.value) {
      d2.value = true;
      e2(N(function(e3) {
        d2.value = true;
        v.value = e3.data !== void 0 ? typeof w.value == "function" ? w.value(v.value, e3.data) : e3.data : e3.data, y2.value = e3.error;
        x.value = e3.extensions;
        p3.value = !!e3.stale;
        h2.value = e3.operation;
      })(onEnd$1(function() {
        d2.value = false;
      })(S.value)).unsubscribe);
    } else {
      d2.value = false;
    }
  }, b));
  var m2 = {
    data: v,
    stale: p3,
    error: y2,
    operation: h2,
    extensions: x,
    fetching: d2,
    isPaused: P2,
    executeSubscription: function executeSubscription(e2) {
      S.value = a.value.executeSubscription(Q2.value, _extends2({}, l3.context, e2));
      return m2;
    },
    pause: function pause() {
      P2.value = true;
    },
    resume: function resume() {
      P2.value = false;
    }
  };
  return m2;
}
function useClientHandle() {
  var e = useClient();
  var u3 = [];
  onBeforeUnmount(function() {
    var e2;
    while (e2 = u3.shift()) {
      e2();
    }
  });
  var n = {
    client: e.value,
    useQuery: function useQuery2(n2) {
      return callUseQuery(n2, e, u3);
    },
    useSubscription: function useSubscription2(n2, r2) {
      return callUseSubscription(n2, r2, e, u3);
    },
    useMutation: function useMutation2(u4) {
      return callUseMutation(u4, e);
    }
  };
  if (true) {
    onMounted(function() {
      _extends2(n, {
        useQuery: function useQuery2(n2) {
          if (!getCurrentInstance()) {
            throw new Error("`handle.useQuery()` should only be called in the `setup()` or a lifecycle hook.");
          }
          return callUseQuery(n2, e, u3);
        },
        useSubscription: function useSubscription2(n2, r2) {
          if (!getCurrentInstance()) {
            throw new Error("`handle.useSubscription()` should only be called in the `setup()` or a lifecycle hook.");
          }
          return callUseSubscription(n2, r2, e, u3);
        }
      });
    });
  }
  return n;
}
var urql_vue_default = install;

// dep:@urql_vue
var urql_vue_default2 = urql_vue_default;
export {
  J2 as Client,
  o as CombinedError,
  cacheExchange,
  composeExchanges,
  W as createClient,
  createRequest,
  debugExchange,
  dedupExchange,
  urql_vue_default2 as default,
  L as defaultExchanges,
  errorExchange,
  G as fallbackExchangeIO,
  fetchExchange,
  formatDocument,
  getOperationName,
  gql,
  install,
  makeErrorResult,
  makeOperation,
  makeResult,
  maskTypename,
  mergeResultPatch,
  provideClient,
  ssrExchange,
  stringifyVariables,
  subscriptionExchange,
  useClientHandle,
  useMutation,
  useQuery,
  useSubscription
};
//# sourceMappingURL=@urql_vue.js.map
