Object.defineProperty(exports, '__esModule', {
  value: true
});

var core = require('@urql/core');

var vue = require('vue');

var wonka = require('wonka');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function provideClient(opts) {
  var client;

  if (!vue.isRef(opts)) {
    client = vue.ref(opts instanceof core.Client ? opts : new core.Client(opts));
  } else {
    client = opts;
  }

  vue.provide('$urql', client);
  return client.value;
}

function install(app, opts) {
  var client;

  if (!vue.isRef(opts)) {
    client = vue.ref(opts instanceof core.Client ? opts : new core.Client(opts));
  } else {
    client = opts;
  }

  app.provide('$urql', client);
}

function useClient() {
  if (process.env.NODE_ENV !== 'production' && !vue.getCurrentInstance()) {
    throw new Error('use* functions may only be called during the `setup()` or other lifecycle hooks.');
  }

  var client = vue.inject('$urql');

  if (process.env.NODE_ENV !== 'production' && !client) {
    throw new Error('No urql Client was provided. Did you forget to install the plugin or call `provideClient` in a parent?');
  }

  return client;
}

function unwrapPossibleProxy(possibleProxy) {
  return possibleProxy && vue.isRef(possibleProxy) ? possibleProxy.value : possibleProxy;
}

var watchOptions$1 = {
  flush: 'pre'
};

function useQuery(args) {
  return callUseQuery(args);
}

function callUseQuery(_args, client, stops) {
  if (client === void 0) client = useClient();
  if (stops === void 0) stops = [];
  var args = vue.reactive(_args);
  var data = vue.ref();
  var stale = vue.ref(false);
  var fetching = vue.ref(false);
  var error = vue.ref();
  var operation = vue.ref();
  var extensions = vue.ref();
  var isPaused = vue.isRef(_args.pause) ? _args.pause : vue.ref(!!_args.pause);
  var request = vue.ref(core.createRequest(args.query, unwrapPossibleProxy(args.variables)));
  var source = vue.ref();
  stops.push(vue.watchEffect(function () {
    var newRequest = core.createRequest(args.query, unwrapPossibleProxy(args.variables));

    if (request.value.key !== newRequest.key) {
      request.value = newRequest;
    }
  }, watchOptions$1));
  stops.push(vue.watchEffect(function () {
    source.value = !isPaused.value ? client.value.executeQuery(request.value, _extends({}, {
      requestPolicy: args.requestPolicy
    }, args.context)) : undefined;
  }, watchOptions$1));
  var state = {
    data: data,
    stale: stale,
    error: error,
    operation: operation,
    extensions: extensions,
    fetching: fetching,
    isPaused: isPaused,
    executeQuery: function executeQuery(opts) {
      var s = source.value = client.value.executeQuery(request.value, _extends({}, {
        requestPolicy: args.requestPolicy
      }, args.context, opts));
      return _extends({}, response, {
        then: function then(onFulfilled, onRejected) {
          return new Promise(function (resolve) {
            var hasResult = false;
            var sub = wonka.subscribe(function () {
              if (!state.fetching.value && !state.stale.value) {
                if (sub) {
                  sub.unsubscribe();
                }

                hasResult = true;
                resolve(state);
              }
            })(s);

            if (hasResult) {
              sub.unsubscribe();
            }
          }).then(onFulfilled, onRejected);
        }
      });
    },
    pause: function pause() {
      isPaused.value = true;
    },
    resume: function resume() {
      isPaused.value = false;
    }
  };
  stops.push(vue.watchEffect(function (onInvalidate) {
    if (source.value) {
      fetching.value = true;
      stale.value = false;
      onInvalidate(wonka.subscribe(function (res) {
        data.value = res.data;
        stale.value = !!res.stale;
        fetching.value = false;
        error.value = res.error;
        operation.value = res.operation;
        extensions.value = res.extensions;
      })(wonka.onEnd(function () {
        fetching.value = false;
        stale.value = false;
      })(source.value)).unsubscribe);
    } else {
      fetching.value = false;
      stale.value = false;
    }
  }, {
    // NOTE: This part of the query pipeline is only initialised once and will need
    // to do so synchronously
    flush: 'sync'
  }));

  var response = _extends({}, state, {
    then: function then(onFulfilled, onRejected) {
      var promise = new Promise(function (resolve) {
        if (!source.value) {
          return resolve(state);
        }

        var hasResult = false;
        var sub = wonka.subscribe(function () {
          if (!state.fetching.value && !state.stale.value) {
            if (sub) {
              sub.unsubscribe();
            }

            hasResult = true;
            resolve(state);
          }
        })(source.value);

        if (hasResult) {
          sub.unsubscribe();
        }
      });
      return promise.then(onFulfilled, onRejected);
    }
  });

  return response;
}
/* eslint-disable react-hooks/rules-of-hooks */


function useMutation(query) {
  return callUseMutation(query);
}

function callUseMutation(query, client) {
  if (client === void 0) client = useClient();
  var data = vue.ref();
  var stale = vue.ref(false);
  var fetching = vue.ref(false);
  var error = vue.ref();
  var operation = vue.ref();
  var extensions = vue.ref();
  return {
    data: data,
    stale: stale,
    fetching: fetching,
    error: error,
    operation: operation,
    extensions: extensions,
    executeMutation: function executeMutation(variables, context) {
      fetching.value = true;
      return wonka.toPromise(wonka.take(1)(client.value.executeMutation(core.createRequest(query, unwrapPossibleProxy(variables)), context || {}))).then(function (res) {
        data.value = res.data;
        stale.value = !!res.stale;
        fetching.value = false;
        error.value = res.error;
        operation.value = res.operation;
        extensions.value = res.extensions;
        return res;
      });
    }
  };
}

var watchOptions = {
  flush: 'pre'
};

function useSubscription(args, handler) {
  return callUseSubscription(args, handler);
}

function callUseSubscription(_args, handler, client, stops) {
  if (client === void 0) client = useClient();
  if (stops === void 0) stops = [];
  var args = vue.reactive(_args);
  var data = vue.ref();
  var stale = vue.ref(false);
  var fetching = vue.ref(false);
  var error = vue.ref();
  var operation = vue.ref();
  var extensions = vue.ref();
  var scanHandler = vue.ref(handler);
  var isPaused = vue.isRef(_args.pause) ? _args.pause : vue.ref(!!_args.pause);
  var request = vue.ref(core.createRequest(args.query, unwrapPossibleProxy(args.variables)));
  var source = vue.ref();
  stops.push(vue.watchEffect(function () {
    var newRequest = core.createRequest(args.query, unwrapPossibleProxy(args.variables));

    if (request.value.key !== newRequest.key) {
      request.value = newRequest;
    }
  }, watchOptions));
  stops.push(vue.watchEffect(function () {
    source.value = !isPaused.value ? client.value.executeSubscription(request.value, _extends({}, args.context)) : undefined;
  }, watchOptions));
  stops.push(vue.watchEffect(function (onInvalidate) {
    if (source.value) {
      fetching.value = true;
      onInvalidate(wonka.subscribe(function (result) {
        fetching.value = true;
        data.value = result.data !== undefined ? typeof scanHandler.value === 'function' ? scanHandler.value(data.value, result.data) : result.data : result.data, error.value = result.error;
        extensions.value = result.extensions;
        stale.value = !!result.stale;
        operation.value = result.operation;
      })(wonka.onEnd(function () {
        fetching.value = false;
      })(source.value)).unsubscribe);
    } else {
      fetching.value = false;
    }
  }, watchOptions));
  var state = {
    data: data,
    stale: stale,
    error: error,
    operation: operation,
    extensions: extensions,
    fetching: fetching,
    isPaused: isPaused,
    executeSubscription: function executeSubscription(opts) {
      source.value = client.value.executeSubscription(request.value, _extends({}, args.context, opts));
      return state;
    },
    pause: function pause() {
      isPaused.value = true;
    },
    resume: function resume() {
      isPaused.value = false;
    }
  };
  return state;
}

function useClientHandle() {
  var client = useClient();
  var stops = [];
  vue.onBeforeUnmount(function () {
    var stop;

    while (stop = stops.shift()) {
      stop();
    }
  });
  var handle = {
    client: client.value,
    useQuery: function useQuery(args) {
      return callUseQuery(args, client, stops);
    },
    useSubscription: function useSubscription(args, handler) {
      return callUseSubscription(args, handler, client, stops);
    },
    useMutation: function useMutation(query) {
      return callUseMutation(query, client);
    }
  };

  if (process.env.NODE_ENV !== 'production') {
    vue.onMounted(function () {
      _extends(handle, {
        useQuery: function useQuery(args) {
          if (process.env.NODE_ENV !== 'production' && !vue.getCurrentInstance()) {
            throw new Error('`handle.useQuery()` should only be called in the `setup()` or a lifecycle hook.');
          }

          return callUseQuery(args, client, stops);
        },
        useSubscription: function useSubscription(args, handler) {
          if (process.env.NODE_ENV !== 'production' && !vue.getCurrentInstance()) {
            throw new Error('`handle.useSubscription()` should only be called in the `setup()` or a lifecycle hook.');
          }

          return callUseSubscription(args, handler, client, stops);
        }
      });
    });
  }

  return handle;
}

exports["default"] = install;
exports.install = install;
exports.provideClient = provideClient;
exports.useClientHandle = useClientHandle;
exports.useMutation = useMutation;
exports.useQuery = useQuery;
exports.useSubscription = useSubscription;
Object.keys(core).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return core[k];
    }
  });
});
//# sourceMappingURL=urql-vue.js.map
