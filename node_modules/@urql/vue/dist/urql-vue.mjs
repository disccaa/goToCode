import { Client as e, createRequest as u } from "@urql/core";

export * from "@urql/core";

import { isRef as n, ref as r, provide as t, getCurrentInstance as a, inject as i, reactive as o, watchEffect as s, onBeforeUnmount as l, onMounted as v } from "vue";

import { subscribe as c, onEnd as f, toPromise as p, take as d } from "wonka";

function _extends() {
  return (_extends = Object.assign || function(e) {
    for (var u = 1; u < arguments.length; u++) {
      var n = arguments[u];
      for (var r in n) {
        if (Object.prototype.hasOwnProperty.call(n, r)) {
          e[r] = n[r];
        }
      }
    }
    return e;
  }).apply(this, arguments);
}

function provideClient(u) {
  var a;
  if (!n(u)) {
    a = r(u instanceof e ? u : new e(u));
  } else {
    a = u;
  }
  t("$urql", a);
  return a.value;
}

function install(u, t) {
  var a;
  if (!n(t)) {
    a = r(t instanceof e ? t : new e(t));
  } else {
    a = t;
  }
  u.provide("$urql", a);
}

function useClient() {
  if ("production" !== process.env.NODE_ENV && !a()) {
    throw new Error("use* functions may only be called during the `setup()` or other lifecycle hooks.");
  }
  var e = i("$urql");
  if ("production" !== process.env.NODE_ENV && !e) {
    throw new Error("No urql Client was provided. Did you forget to install the plugin or call `provideClient` in a parent?");
  }
  return e;
}

function unwrapPossibleProxy(e) {
  return e && n(e) ? e.value : e;
}

var y = {
  flush: "pre"
};

function useQuery(e) {
  return callUseQuery(e);
}

function callUseQuery(e, t, a) {
  if (void 0 === t) {
    t = useClient();
  }
  if (void 0 === a) {
    a = [];
  }
  var i = o(e);
  var l = r();
  var v = r(!1);
  var p = r(!1);
  var d = r();
  var b = r();
  var h = r();
  var x = n(e.pause) ? e.pause : r(!!e.pause);
  var w = r(u(i.query, unwrapPossibleProxy(i.variables)));
  var P = r();
  a.push(s((function() {
    var e = u(i.query, unwrapPossibleProxy(i.variables));
    if (w.value.key !== e.key) {
      w.value = e;
    }
  }), y));
  a.push(s((function() {
    P.value = !x.value ? t.value.executeQuery(w.value, _extends({}, {
      requestPolicy: i.requestPolicy
    }, i.context)) : void 0;
  }), y));
  var Q = {
    data: l,
    stale: v,
    error: d,
    operation: b,
    extensions: h,
    fetching: p,
    isPaused: x,
    executeQuery: function executeQuery(e) {
      var u = P.value = t.value.executeQuery(w.value, _extends({}, {
        requestPolicy: i.requestPolicy
      }, i.context, e));
      return _extends({}, S, {
        then: function then(e, n) {
          return new Promise((function(e) {
            var n = !1;
            var r = c((function() {
              if (!Q.fetching.value && !Q.stale.value) {
                if (r) {
                  r.unsubscribe();
                }
                n = !0;
                e(Q);
              }
            }))(u);
            if (n) {
              r.unsubscribe();
            }
          })).then(e, n);
        }
      });
    },
    pause: function pause() {
      x.value = !0;
    },
    resume: function resume() {
      x.value = !1;
    }
  };
  a.push(s((function(e) {
    if (P.value) {
      p.value = !0;
      v.value = !1;
      e(c((function(e) {
        l.value = e.data;
        v.value = !!e.stale;
        p.value = !1;
        d.value = e.error;
        b.value = e.operation;
        h.value = e.extensions;
      }))(f((function() {
        p.value = !1;
        v.value = !1;
      }))(P.value)).unsubscribe);
    } else {
      p.value = !1;
      v.value = !1;
    }
  }), {
    flush: "sync"
  }));
  var S = _extends({}, Q, {
    then: function then(e, u) {
      return new Promise((function(e) {
        if (!P.value) {
          return e(Q);
        }
        var u = !1;
        var n = c((function() {
          if (!Q.fetching.value && !Q.stale.value) {
            if (n) {
              n.unsubscribe();
            }
            u = !0;
            e(Q);
          }
        }))(P.value);
        if (u) {
          n.unsubscribe();
        }
      })).then(e, u);
    }
  });
  return S;
}

function useMutation(e) {
  return callUseMutation(e);
}

function callUseMutation(e, n) {
  if (void 0 === n) {
    n = useClient();
  }
  var t = r();
  var a = r(!1);
  var i = r(!1);
  var o = r();
  var s = r();
  var l = r();
  return {
    data: t,
    stale: a,
    fetching: i,
    error: o,
    operation: s,
    extensions: l,
    executeMutation: function executeMutation(r, v) {
      i.value = !0;
      return p(d(1)(n.value.executeMutation(u(e, unwrapPossibleProxy(r)), v || {}))).then((function(e) {
        t.value = e.data;
        a.value = !!e.stale;
        i.value = !1;
        o.value = e.error;
        s.value = e.operation;
        l.value = e.extensions;
        return e;
      }));
    }
  };
}

var b = {
  flush: "pre"
};

function useSubscription(e, u) {
  return callUseSubscription(e, u);
}

function callUseSubscription(e, t, a, i) {
  if (void 0 === a) {
    a = useClient();
  }
  if (void 0 === i) {
    i = [];
  }
  var l = o(e);
  var v = r();
  var p = r(!1);
  var d = r(!1);
  var y = r();
  var h = r();
  var x = r();
  var w = r(t);
  var P = n(e.pause) ? e.pause : r(!!e.pause);
  var Q = r(u(l.query, unwrapPossibleProxy(l.variables)));
  var S = r();
  i.push(s((function() {
    var e = u(l.query, unwrapPossibleProxy(l.variables));
    if (Q.value.key !== e.key) {
      Q.value = e;
    }
  }), b));
  i.push(s((function() {
    S.value = !P.value ? a.value.executeSubscription(Q.value, _extends({}, l.context)) : void 0;
  }), b));
  i.push(s((function(e) {
    if (S.value) {
      d.value = !0;
      e(c((function(e) {
        d.value = !0;
        v.value = void 0 !== e.data ? "function" == typeof w.value ? w.value(v.value, e.data) : e.data : e.data, 
        y.value = e.error;
        x.value = e.extensions;
        p.value = !!e.stale;
        h.value = e.operation;
      }))(f((function() {
        d.value = !1;
      }))(S.value)).unsubscribe);
    } else {
      d.value = !1;
    }
  }), b));
  var m = {
    data: v,
    stale: p,
    error: y,
    operation: h,
    extensions: x,
    fetching: d,
    isPaused: P,
    executeSubscription: function executeSubscription(e) {
      S.value = a.value.executeSubscription(Q.value, _extends({}, l.context, e));
      return m;
    },
    pause: function pause() {
      P.value = !0;
    },
    resume: function resume() {
      P.value = !1;
    }
  };
  return m;
}

function useClientHandle() {
  var e = useClient();
  var u = [];
  l((function() {
    var e;
    while (e = u.shift()) {
      e();
    }
  }));
  var n = {
    client: e.value,
    useQuery: function useQuery(n) {
      return callUseQuery(n, e, u);
    },
    useSubscription: function useSubscription(n, r) {
      return callUseSubscription(n, r, e, u);
    },
    useMutation: function useMutation(u) {
      return callUseMutation(u, e);
    }
  };
  if ("production" !== process.env.NODE_ENV) {
    v((function() {
      _extends(n, {
        useQuery: function useQuery(n) {
          if ("production" !== process.env.NODE_ENV && !a()) {
            throw new Error("`handle.useQuery()` should only be called in the `setup()` or a lifecycle hook.");
          }
          return callUseQuery(n, e, u);
        },
        useSubscription: function useSubscription(n, r) {
          if ("production" !== process.env.NODE_ENV && !a()) {
            throw new Error("`handle.useSubscription()` should only be called in the `setup()` or a lifecycle hook.");
          }
          return callUseSubscription(n, r, e, u);
        }
      });
    }));
  }
  return n;
}

export default install;

export { install, provideClient, useClientHandle, useMutation, useQuery, useSubscription };
//# sourceMappingURL=urql-vue.mjs.map
