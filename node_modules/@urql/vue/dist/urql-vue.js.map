{"version":3,"file":"urql-vue.js","sources":["../src/useClient.ts","../src/utils.ts","../src/useQuery.ts","../src/useMutation.ts","../src/useSubscription.ts","../src/useClientHandle.ts"],"sourcesContent":["import { App, getCurrentInstance, inject, provide, Ref, isRef, ref } from 'vue';\nimport { Client, ClientOptions } from '@urql/core';\n\nexport function provideClient(opts: ClientOptions | Client | Ref<Client>) {\n  let client: Ref<Client>;\n  if (!isRef(opts)) {\n    client = ref(opts instanceof Client ? opts : new Client(opts));\n  } else {\n    client = opts;\n  }\n\n  provide('$urql', client);\n  return client.value;\n}\n\nexport function install(app: App, opts: ClientOptions | Client | Ref<Client>) {\n  let client: Ref<Client>;\n  if (!isRef(opts)) {\n    client = ref(opts instanceof Client ? opts : new Client(opts));\n  } else {\n    client = opts;\n  }\n  app.provide('$urql', client);\n}\n\nexport function useClient(): Ref<Client> {\n  if (process.env.NODE_ENV !== 'production' && !getCurrentInstance()) {\n    throw new Error(\n      'use* functions may only be called during the `setup()` or other lifecycle hooks.'\n    );\n  }\n\n  const client = inject('$urql') as Ref<Client>;\n  if (process.env.NODE_ENV !== 'production' && !client) {\n    throw new Error(\n      'No urql Client was provided. Did you forget to install the plugin or call `provideClient` in a parent?'\n    );\n  }\n\n  return client;\n}\n","import { Ref, isRef } from 'vue';\n\nexport function unwrapPossibleProxy<V>(\n  possibleProxy: V | Ref<V> | undefined\n): V | undefined {\n  return possibleProxy && isRef(possibleProxy)\n    ? possibleProxy.value\n    : possibleProxy;\n}\n","/* eslint-disable react-hooks/rules-of-hooks */\n\nimport { DocumentNode } from 'graphql';\n\nimport { WatchStopHandle, Ref, ref, watchEffect, reactive, isRef } from 'vue';\n\nimport { Source, pipe, subscribe, onEnd } from 'wonka';\n\nimport {\n  Client,\n  OperationResult,\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  RequestPolicy,\n  Operation,\n  createRequest,\n  GraphQLRequest,\n} from '@urql/core';\n\nimport { useClient } from './useClient';\nimport { unwrapPossibleProxy } from './utils';\n\ntype MaybeRef<T> = T | Ref<T>;\n\nexport interface UseQueryArgs<T = any, V = object> {\n  query: MaybeRef<TypedDocumentNode<T, V> | DocumentNode | string>;\n  variables?: MaybeRef<V>;\n  requestPolicy?: MaybeRef<RequestPolicy>;\n  context?: MaybeRef<Partial<OperationContext>>;\n  pause?: MaybeRef<boolean>;\n}\n\nexport type QueryPartialState<T = any, V = object> = Partial<\n  OperationResult<T, V>\n> & { fetching?: boolean };\n\nexport interface UseQueryState<T = any, V = object> {\n  fetching: Ref<boolean>;\n  stale: Ref<boolean>;\n  data: Ref<T | undefined>;\n  error: Ref<CombinedError | undefined>;\n  extensions: Ref<Record<string, any> | undefined>;\n  operation: Ref<Operation<T, V> | undefined>;\n  isPaused: Ref<boolean>;\n  resume(): void;\n  pause(): void;\n  executeQuery(opts?: Partial<OperationContext>): UseQueryResponse<T, V>;\n}\n\nexport type UseQueryResponse<T, V> = UseQueryState<T, V> &\n  PromiseLike<UseQueryState<T, V>>;\n\nconst watchOptions = {\n  flush: 'pre' as const,\n};\n\nexport function useQuery<T = any, V = object>(\n  args: UseQueryArgs<T, V>\n): UseQueryResponse<T, V> {\n  return callUseQuery(args);\n}\n\nexport function callUseQuery<T = any, V = object>(\n  _args: UseQueryArgs<T, V>,\n  client: Ref<Client> = useClient(),\n  stops: WatchStopHandle[] = []\n): UseQueryResponse<T, V> {\n  const args = reactive(_args);\n\n  const data: Ref<T | undefined> = ref();\n  const stale: Ref<boolean> = ref(false);\n  const fetching: Ref<boolean> = ref(false);\n  const error: Ref<CombinedError | undefined> = ref();\n  const operation: Ref<Operation<T, V> | undefined> = ref();\n  const extensions: Ref<Record<string, any> | undefined> = ref();\n\n  const isPaused: Ref<boolean> = isRef(_args.pause)\n    ? _args.pause\n    : ref(!!_args.pause);\n\n  const request: Ref<GraphQLRequest<T, V>> = ref(\n    createRequest<T, V>(\n      args.query,\n      unwrapPossibleProxy<V>(args.variables as V)\n    ) as any\n  );\n\n  const source: Ref<Source<OperationResult> | undefined> = ref();\n\n  stops.push(\n    watchEffect(() => {\n      const newRequest = createRequest<T, V>(\n        args.query,\n        unwrapPossibleProxy<V>(args.variables as V)\n      );\n      if (request.value.key !== newRequest.key) {\n        request.value = newRequest;\n      }\n    }, watchOptions)\n  );\n\n  stops.push(\n    watchEffect(() => {\n      source.value = !isPaused.value\n        ? client.value.executeQuery<T, V>(request.value, {\n            requestPolicy: args.requestPolicy,\n            ...args.context,\n          })\n        : undefined;\n    }, watchOptions)\n  );\n\n  const state: UseQueryState<T, V> = {\n    data,\n    stale,\n    error,\n    operation,\n    extensions,\n    fetching,\n    isPaused,\n    executeQuery(opts?: Partial<OperationContext>): UseQueryResponse<T, V> {\n      const s = (source.value = client.value.executeQuery<T, V>(request.value, {\n        requestPolicy: args.requestPolicy,\n        ...args.context,\n        ...opts,\n      }));\n\n      return {\n        ...response,\n        then(onFulfilled, onRejected) {\n          return new Promise<UseQueryState<T, V>>(resolve => {\n            let hasResult = false;\n            const sub = pipe(\n              s,\n              subscribe(() => {\n                if (!state.fetching.value && !state.stale.value) {\n                  if (sub) sub.unsubscribe();\n                  hasResult = true;\n                  resolve(state);\n                }\n              })\n            );\n            if (hasResult) sub.unsubscribe();\n          }).then(onFulfilled, onRejected);\n        },\n      };\n    },\n    pause() {\n      isPaused.value = true;\n    },\n    resume() {\n      isPaused.value = false;\n    },\n  };\n\n  stops.push(\n    watchEffect(\n      onInvalidate => {\n        if (source.value) {\n          fetching.value = true;\n          stale.value = false;\n\n          onInvalidate(\n            pipe(\n              source.value,\n              onEnd(() => {\n                fetching.value = false;\n                stale.value = false;\n              }),\n              subscribe(res => {\n                data.value = res.data;\n                stale.value = !!res.stale;\n                fetching.value = false;\n                error.value = res.error;\n                operation.value = res.operation;\n                extensions.value = res.extensions;\n              })\n            ).unsubscribe\n          );\n        } else {\n          fetching.value = false;\n          stale.value = false;\n        }\n      },\n      {\n        // NOTE: This part of the query pipeline is only initialised once and will need\n        // to do so synchronously\n        flush: 'sync',\n      }\n    )\n  );\n\n  const response: UseQueryResponse<T, V> = {\n    ...state,\n    then(onFulfilled, onRejected) {\n      const promise = new Promise<UseQueryState<T, V>>(resolve => {\n        if (!source.value) return resolve(state);\n        let hasResult = false;\n        const sub = pipe(\n          source.value,\n          subscribe(() => {\n            if (!state.fetching.value && !state.stale.value) {\n              if (sub) sub.unsubscribe();\n              hasResult = true;\n              resolve(state);\n            }\n          })\n        );\n        if (hasResult) sub.unsubscribe();\n      });\n\n      return promise.then(onFulfilled, onRejected);\n    },\n  };\n\n  return response;\n}\n","/* eslint-disable react-hooks/rules-of-hooks */\n\nimport { ref, Ref } from 'vue';\nimport { DocumentNode } from 'graphql';\nimport { pipe, toPromise, take } from 'wonka';\n\nimport {\n  Client,\n  TypedDocumentNode,\n  CombinedError,\n  Operation,\n  OperationContext,\n  OperationResult,\n  createRequest,\n} from '@urql/core';\n\nimport { useClient } from './useClient';\nimport { unwrapPossibleProxy } from './utils';\n\nexport interface UseMutationState<T, V> {\n  fetching: Ref<boolean>;\n  stale: Ref<boolean>;\n  data: Ref<T | undefined>;\n  error: Ref<CombinedError | undefined>;\n  extensions: Ref<Record<string, any> | undefined>;\n  operation: Ref<Operation<T, V> | undefined>;\n  executeMutation: (\n    variables: V,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<T>>;\n}\n\nexport type UseMutationResponse<T, V> = UseMutationState<T, V>;\n\nexport function useMutation<T = any, V = any>(\n  query: TypedDocumentNode<T, V> | DocumentNode | string\n): UseMutationResponse<T, V> {\n  return callUseMutation(query);\n}\n\nexport function callUseMutation<T = any, V = any>(\n  query: TypedDocumentNode<T, V> | DocumentNode | string,\n  client: Ref<Client> = useClient()\n): UseMutationResponse<T, V> {\n  const data: Ref<T | undefined> = ref();\n  const stale: Ref<boolean> = ref(false);\n  const fetching: Ref<boolean> = ref(false);\n  const error: Ref<CombinedError | undefined> = ref();\n  const operation: Ref<Operation<T, V> | undefined> = ref();\n  const extensions: Ref<Record<string, any> | undefined> = ref();\n\n  return {\n    data,\n    stale,\n    fetching,\n    error,\n    operation,\n    extensions,\n    executeMutation(\n      variables: V,\n      context?: Partial<OperationContext>\n    ): Promise<OperationResult<T, V>> {\n      fetching.value = true;\n\n      return pipe(\n        client.value.executeMutation<T, V>(\n          createRequest<T, V>(query, unwrapPossibleProxy<V>(variables)),\n          context || {}\n        ),\n        take(1),\n        toPromise\n      ).then((res: OperationResult) => {\n        data.value = res.data;\n        stale.value = !!res.stale;\n        fetching.value = false;\n        error.value = res.error;\n        operation.value = res.operation;\n        extensions.value = res.extensions;\n        return res;\n      });\n    },\n  };\n}\n","/* eslint-disable react-hooks/rules-of-hooks */\n\nimport { DocumentNode } from 'graphql';\nimport { Source, pipe, subscribe, onEnd } from 'wonka';\n\nimport { WatchStopHandle, Ref, ref, watchEffect, reactive, isRef } from 'vue';\n\nimport {\n  Client,\n  OperationResult,\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  Operation,\n  createRequest,\n  GraphQLRequest,\n} from '@urql/core';\n\nimport { useClient } from './useClient';\nimport { unwrapPossibleProxy } from './utils';\n\ntype MaybeRef<T> = T | Ref<T>;\n\nexport interface UseSubscriptionArgs<T = any, V = object> {\n  query: MaybeRef<TypedDocumentNode<T, V> | DocumentNode | string>;\n  variables?: MaybeRef<V>;\n  pause?: MaybeRef<boolean>;\n  context?: MaybeRef<Partial<OperationContext>>;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\nexport type SubscriptionHandlerArg<T, R> = MaybeRef<SubscriptionHandler<T, R>>;\n\nexport interface UseSubscriptionState<T = any, R = T, V = object> {\n  fetching: Ref<boolean>;\n  stale: Ref<boolean>;\n  data: Ref<R | undefined>;\n  error: Ref<CombinedError | undefined>;\n  extensions: Ref<Record<string, any> | undefined>;\n  operation: Ref<Operation<T, V> | undefined>;\n  isPaused: Ref<boolean>;\n  resume(): void;\n  pause(): void;\n  executeSubscription(opts?: Partial<OperationContext>): void;\n}\n\nexport type UseSubscriptionResponse<\n  T = any,\n  R = T,\n  V = object\n> = UseSubscriptionState<T, R, V>;\n\nconst watchOptions = {\n  flush: 'pre' as const,\n};\n\nexport function useSubscription<T = any, R = T, V = object>(\n  args: UseSubscriptionArgs<T, V>,\n  handler?: SubscriptionHandlerArg<T, R>\n): UseSubscriptionResponse<T, R, V> {\n  return callUseSubscription(args, handler);\n}\n\nexport function callUseSubscription<T = any, R = T, V = object>(\n  _args: UseSubscriptionArgs<T, V>,\n  handler?: SubscriptionHandlerArg<T, R>,\n  client: Ref<Client> = useClient(),\n  stops: WatchStopHandle[] = []\n): UseSubscriptionResponse<T, R, V> {\n  const args = reactive(_args);\n\n  const data: Ref<R | undefined> = ref();\n  const stale: Ref<boolean> = ref(false);\n  const fetching: Ref<boolean> = ref(false);\n  const error: Ref<CombinedError | undefined> = ref();\n  const operation: Ref<Operation | undefined> = ref();\n  const extensions: Ref<Record<string, any> | undefined> = ref();\n\n  const scanHandler: Ref<SubscriptionHandler<T, R> | undefined> = ref(handler);\n\n  const isPaused: Ref<boolean> = isRef(_args.pause)\n    ? _args.pause\n    : ref(!!_args.pause);\n\n  const request: Ref<GraphQLRequest<T, V>> = ref(\n    createRequest<T, V>(\n      args.query,\n      unwrapPossibleProxy<V>(args.variables as V)\n    ) as any\n  );\n\n  const source: Ref<Source<OperationResult<T, V>> | undefined> = ref();\n\n  stops.push(\n    watchEffect(() => {\n      const newRequest = createRequest<T, V>(\n        args.query,\n        unwrapPossibleProxy<V>(args.variables as V)\n      );\n      if (request.value.key !== newRequest.key) {\n        request.value = newRequest;\n      }\n    }, watchOptions)\n  );\n\n  stops.push(\n    watchEffect(() => {\n      source.value = !isPaused.value\n        ? client.value.executeSubscription<T, V>(request.value, {\n            ...args.context,\n          })\n        : undefined;\n    }, watchOptions)\n  );\n\n  stops.push(\n    watchEffect(onInvalidate => {\n      if (source.value) {\n        fetching.value = true;\n\n        onInvalidate(\n          pipe(\n            source.value,\n            onEnd(() => {\n              fetching.value = false;\n            }),\n            subscribe(result => {\n              fetching.value = true;\n              (data.value =\n                result.data !== undefined\n                  ? typeof scanHandler.value === 'function'\n                    ? scanHandler.value(data.value as any, result.data!)\n                    : result.data\n                  : (result.data as any)),\n                (error.value = result.error);\n              extensions.value = result.extensions;\n              stale.value = !!result.stale;\n              operation.value = result.operation;\n            })\n          ).unsubscribe\n        );\n      } else {\n        fetching.value = false;\n      }\n    }, watchOptions)\n  );\n\n  const state: UseSubscriptionState<T, R, V> = {\n    data,\n    stale,\n    error,\n    operation,\n    extensions,\n    fetching,\n    isPaused,\n    executeSubscription(\n      opts?: Partial<OperationContext>\n    ): UseSubscriptionState<T, R, V> {\n      source.value = client.value.executeSubscription<T, V>(request.value, {\n        ...args.context,\n        ...opts,\n      });\n\n      return state;\n    },\n    pause() {\n      isPaused.value = true;\n    },\n    resume() {\n      isPaused.value = false;\n    },\n  };\n\n  return state;\n}\n","import { DocumentNode } from 'graphql';\nimport { Client, TypedDocumentNode } from '@urql/core';\nimport {\n  WatchStopHandle,\n  getCurrentInstance,\n  onMounted,\n  onBeforeUnmount,\n} from 'vue';\n\nimport { useClient } from './useClient';\n\nimport { callUseQuery, UseQueryArgs, UseQueryResponse } from './useQuery';\n\nimport { callUseMutation, UseMutationResponse } from './useMutation';\n\nimport {\n  callUseSubscription,\n  UseSubscriptionArgs,\n  SubscriptionHandlerArg,\n  UseSubscriptionResponse,\n} from './useSubscription';\n\nexport interface ClientHandle {\n  client: Client;\n\n  useQuery<T = any, V = object>(\n    args: UseQueryArgs<T, V>\n  ): UseQueryResponse<T, V>;\n\n  useSubscription<T = any, R = T, V = object>(\n    args: UseSubscriptionArgs<T, V>,\n    handler?: SubscriptionHandlerArg<T, R>\n  ): UseSubscriptionResponse<T, R, V>;\n\n  useMutation<T = any, V = any>(\n    query: TypedDocumentNode<T, V> | DocumentNode | string\n  ): UseMutationResponse<T, V>;\n}\n\nexport function useClientHandle(): ClientHandle {\n  const client = useClient();\n  const stops: WatchStopHandle[] = [];\n\n  onBeforeUnmount(() => {\n    let stop: WatchStopHandle | void;\n    while ((stop = stops.shift())) stop();\n  });\n\n  const handle: ClientHandle = {\n    client: client.value,\n\n    useQuery<T = any, V = object>(\n      args: UseQueryArgs<T, V>\n    ): UseQueryResponse<T, V> {\n      return callUseQuery(args, client, stops);\n    },\n\n    useSubscription<T = any, R = T, V = object>(\n      args: UseSubscriptionArgs<T, V>,\n      handler?: SubscriptionHandlerArg<T, R>\n    ): UseSubscriptionResponse<T, R, V> {\n      return callUseSubscription(args, handler, client, stops);\n    },\n\n    useMutation<T = any, V = any>(\n      query: TypedDocumentNode<T, V> | DocumentNode | string\n    ): UseMutationResponse<T, V> {\n      return callUseMutation(query, client);\n    },\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    onMounted(() => {\n      Object.assign(handle, {\n        useQuery<T = any, V = object>(\n          args: UseQueryArgs<T, V>\n        ): UseQueryResponse<T, V> {\n          if (process.env.NODE_ENV !== 'production' && !getCurrentInstance()) {\n            throw new Error(\n              '`handle.useQuery()` should only be called in the `setup()` or a lifecycle hook.'\n            );\n          }\n\n          return callUseQuery(args, client, stops);\n        },\n\n        useSubscription<T = any, R = T, V = object>(\n          args: UseSubscriptionArgs<T, V>,\n          handler?: SubscriptionHandlerArg<T, R>\n        ): UseSubscriptionResponse<T, R, V> {\n          if (process.env.NODE_ENV !== 'production' && !getCurrentInstance()) {\n            throw new Error(\n              '`handle.useSubscription()` should only be called in the `setup()` or a lifecycle hook.'\n            );\n          }\n\n          return callUseSubscription(args, handler, client, stops);\n        },\n      });\n    });\n  }\n\n  return handle;\n}\n"],"names":["provideClient","opts","let","client","isRef","ref","Client","provide","install","app","useClient","Error","const","inject","unwrapPossibleProxy","possibleProxy","watchOptions","flush","useQuery","args","callUseQuery","_args","stops","reactive","data","stale","fetching","error","operation","extensions","isPaused","pause","request","createRequest","query","variables","source","push","watchEffect","newRequest","value","state","executeQuery","s","response","Promise","resolve","sub","hasResult","onInvalidate","subscribe","res","unsubscribe","promise","useMutation","callUseMutation","toPromise","take","executeMutation","context","then","useSubscription","handler","callUseSubscription","scanHandler","result","executeSubscription","useClientHandle","stop","shift","handle","process","env","NODE_ENV"],"mappings":"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"}